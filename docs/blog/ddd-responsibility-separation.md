
## 들어가며

[이전 글](https://velog.io/@praesentia-ykm)에서 33개의 Q&A로 설계를 먼저 한 이야기를 했다. 이번에는 그 설계 과정에서 가장 머리를 싸맸던 부분 — **"이 코드를 어디에 둬야 하는가?"** — 에 대해 써보려 한다.

DDD(Domain-Driven Design)를 공부하면 "바운디드 컨텍스트", "어그리게이트", "도메인 서비스" 같은 용어가 쏟아진다. 개념 자체는 어렵지 않다. 문제는 **실제 코드에 적용하려 할 때** 발생한다.

> "ProductService에 있어야 해, 아니면 ProductFacade에 있어야 해?"
> "Stock이랑 Product를 한 테이블에 두면 안 돼?"
> "LikeFacade가 ProductService를 직접 부르는 게 맞아?"

이런 질문에 "상황에 따라 다릅니다"는 답이 되지 않는다. **어떤 상황에서 어떻게 달라지는지**, 그 갈림길의 기준을 찾고 싶었다.

---

## 내가 처음 그린 설계 흐름, 그리고 수정

DDD를 나름대로 공부하고 처음 머릿속에 그린 설계 흐름은 이랬다.

```
1. 최상위 도메인 구분
2. 유비쿼터스 언어 구분
3. 바운디드 컨텍스트 구분
4. 루트 어그리게이트
5. 레이어 구분
6. 도메인 서비스 / 비즈니스 서비스
```

뭔가 그럴듯해 보인다. 그런데 이 흐름대로 설계를 해보니 세 군데서 걸렸다.

### 걸림돌 1 — 유비쿼터스 언어와 바운디드 컨텍스트는 분리할 수 없다

2번에서 "유비쿼터스 언어를 정리"하고, 3번에서 "바운디드 컨텍스트를 나누자"라고 했는데 — 이 두 개는 순차적으로 할 수 있는 일이 아니었다.

"상품"이라는 단어를 정의하려는 순간, **카탈로그 팀에서의 "상품"과 주문 팀에서의 "상품"이 다르다**는 걸 발견한다. 이 발견 자체가 곧 경계를 긋는 행위다.

비유를 들자면, 지도에서 국경선을 긋는 것과 각 나라의 공용어를 정하는 것이다. "여기서부터 이 언어가 통하지 않는다"를 발견하는 순간이 곧 국경선이 그어지는 순간이다. 언어를 먼저 정하고 국경을 그리는 게 아니라, **언어 차이가 국경을 드러낸다.**

### 걸림돌 2 — 컨텍스트 매핑이 빠져 있었다

바운디드 컨텍스트를 나눈 건 좋은데, **"나눈 것들이 서로 어떻게 대화하는가?"**를 정의하는 단계가 없었다. 카탈로그와 주문이 분리되었으면 주문할 때 상품 정보를 어떻게 가져올지, 좋아요 수를 어떻게 갱신할지 — 이 통신 방식을 결정하는 게 컨텍스트 매핑이다.

이걸 빼먹으면 "잘 나눈 것 같은데 결국 다 얽혀있네?"라는 상황이 된다.

### 걸림돌 3 — "비즈니스 서비스"라는 건 없다

마지막에 "도메인 서비스 / 비즈니스 서비스"라고 적었는데, DDD에는 "비즈니스 서비스"라는 용어가 없다. 내가 "비즈니스 서비스"라고 부르고 있던 것은 사실 **애플리케이션 서비스**였다.

이름이 중요한 게 아니라고 생각할 수 있지만, 이름이 모호하면 기준도 모호해진다. "비즈니스 서비스에 뭘 넣지?"라는 질문에는 "비즈니스 로직?"이라는 동어반복밖에 나오지 않는다. "애플리케이션 서비스에 뭘 넣지?"라는 질문에는 "유스케이스 절차"라는 명확한 답이 나온다.

### 수정된 흐름

세 가지를 고치면 이렇게 된다.

```
수정 전                              수정 후
─────────────────                   ─────────────────
1. 최상위 도메인 구분           →   1. 서브도메인 식별 + 분류 (Core/Supporting/Generic)
2. 유비쿼터스 언어 구분    ┐        2. 유비쿼터스 언어 ↔ 바운디드 컨텍스트 (동시 발견)
3. 바운디드 컨텍스트 구분  ┘
   (빠짐)                      →   3. 컨텍스트 매핑 (관계 정의)
4. 루트 어그리게이트           →   4. 전술적 설계 (어그리게이트 + 엔티티/VO)
5. 레이어 구분                 →   5. 레이어드 아키텍처
6. 도메인 서비스/비즈니스 서비스 →   6. 도메인 서비스 vs 애플리케이션 서비스 (용어 정정)
```

방향 자체가 틀렸던 건 아니다. 다만 2번과 3번이 하나의 동시 과정이라는 것, 컨텍스트 매핑이 빠져 있었다는 것, 용어가 부정확했다는 것 — 이 세 가지를 인식하니 설계가 더 선명해졌다.

---

## "상품이 뭔데?" — 바운디드 컨텍스트의 경계를 찾는 법

위에서 "언어 차이가 곧 경계"라고 했다. 그 과정을 실제 코드로 보여주겠다.

현재 `ProductModel`은 이렇게 생겼다.

```java
public class ProductModel extends BaseEntity {
    private String name;        // ← "상품을 전시한다" 관점
    private String description; // ← "상품을 전시한다" 관점
    private Money price;        // ← "상품의 가치를 매긴다" 관점
    private Long brandId;       // ← "상품이 어떤 브랜드인지" 관점
    private int likeCount;      // ← "상품이 얼마나 인기있는지" 관점
}
```

하나의 클래스에 다섯 가지 관심사가 공존한다. 이 상태에서 "상품이 뭔데?"라고 물어보면 맥락마다 답이 완전히 다르다.

| 맥락 | "상품"의 의미 | 관심 있는 속성 | 관심 없는 속성 |
|------|-------------|---------------|---------------|
| **카탈로그** | 고객에게 보여줄 전시물 | name, description, price, brand | quantity, likeCount |
| **재고** | 창고에서 관리할 물건 | productId, quantity, status | name, description, brand |
| **좋아요** | 사용자가 선호를 표현한 대상 | productId (참조만) | name, price, quantity |
| **주문** | 거래의 대상 (가격이 확정된 시점) | productId, 주문시점가격, 수량 | 현재가격, 재고, 좋아요 |

같은 "상품"인데 **필요한 속성이 완전히 다르다.** 이 차이가 바운디드 컨텍스트의 경계다.

### 기준을 한 문장으로 요약하면

> **같은 단어가 다른 속성/행위를 요구하는 지점 = 바운디드 컨텍스트 경계**

단, 이 기준은 **같은 도메인 용어가 여러 맥락에서 쓰일 때만** 적용된다. 애초에 다른 단어를 쓰는 영역(예: "상품"과 "결제수단")은 비즈니스 관심사 자체가 다르므로 별도 컨텍스트다.

### 무의식적으로 이미 적용하고 있었다

Q&A 브레인스토밍을 하면서 나도 모르게 이 경계를 지키고 있었다.

- `LikeModel`은 `ProductModel`을 직접 참조하지 않고 `productId`만 보유한다.
- `StockModel`도 `productId`만 보유한다.
- `OrderItemModel`에는 주문 시점의 `productName`, `productPrice`를 **스냅샷**으로 복사한다.

즉, 각 도메인은 "상품" 전체를 알 필요 없이 자기에게 필요한 단편만 들고 있다. 이것이 바로 바운디드 컨텍스트 간의 **느슨한 참조(ID 참조)**이고, 의식하든 안 하든 자연스럽게 흘러가는 설계의 방향이었다.

---

## 서브도메인 분류 — "어디에 시간을 쓸 것인가"

경계를 나눈 다음에는 "이 중에 뭐가 제일 중요한가?"를 판단해야 한다. DDD에서는 이걸 서브도메인 분류라고 부른다.

| 유형 | 의미 | 설계 전략 |
|------|------|-----------|
| **Core** | 비즈니스 경쟁력의 핵심 | 직접 설계하고 정교하게 구현 |
| **Supporting** | Core를 보조. 중요하지만 차별화 요소는 아님 | 직접 구현하되 Core만큼의 투자는 불필요 |
| **Generic** | 어디서나 비슷하게 필요한 범용 기능 | 외부 솔루션 사용 가능 |

이커머스에서 이걸 적용하면:

| 서브도메인 | 유형 | 왜? |
|-----------|------|-----|
| **카탈로그** (상품 + 브랜드) | Core | 고객에게 보여줄 상품을 관리. 비즈니스 전시의 핵심 |
| **주문** | Core | 거래를 기록하고 관리. 매출의 직접적 근간 |
| **재고** | Supporting | 주문과 카탈로그를 보조. 중요하지만 그 자체가 경쟁력은 아님 |
| **좋아요** | Supporting | 고객 선호 추적. 카탈로그의 인기순 정렬에 활용 |
| **회원/인증** | Generic | 어디서나 비슷한 범용 기능. 외부 솔루션 대체 가능 |

이 분류가 코드에 주는 영향은 명확하다. 카탈로그와 주문은 도메인 모델을 정교하게 설계하고, 회원/인증은 `userId`만 받아서 참조한다. 실제로 현재 코드에서 `MemberFacade`는 단순한 CRUD뿐이고, `OrderFacade`는 재고 차감, 스냅샷 생성, All or Nothing 검증까지 복잡한 규칙이 들어있다.

---

## 브랜드와 상품이 같은 BC인 이유 — 트랜잭션이 답했다

바운디드 컨텍스트를 나누다 보면 "이 둘은 같은 데 넣어야 하나, 따로 빼야 하나?"라는 판단이 필요하다. Brand와 Product가 그랬다.

직감적으로는 분리하고 싶었다. 브랜드는 브랜드고 상품은 상품이니까. 그런데 Q&A 과정에서 이런 질문을 던졌었다.

> **Q1: 브랜드를 삭제하면 소속 상품은 어떻게 되는가?**

답은 "브랜드 삭제 시 소속 상품 전체를 연쇄 soft delete"였고, 이것은 **하나의 트랜잭션**으로 처리되어야 했다.

```java
// BrandFacade — 하나의 트랜잭션 안에서 브랜드 + 소속 상품 전체 삭제
@Transactional
public void deleteBrand(Long brandId) {
    brandService.delete(brandId);                              // 브랜드 soft delete
    productService.softDeleteByBrandId(brandId);               // 소속 상품 전체 soft delete
}
```

만약 Brand와 Product가 다른 바운디드 컨텍스트에 있다면 이 트랜잭션은 **분산 트랜잭션**이 된다. 모놀리스에서는 문제없지만, 시스템을 분리하는 순간 Saga 패턴 같은 복잡한 메커니즘이 필요해진다. "브랜드 삭제"라는 단순한 요구사항에 그 복잡도는 과하다.

**결론:** 하나의 트랜잭션으로 처리되어야 하는 연산이 있으면, 같은 바운디드 컨텍스트에 둔다.

---

## 어그리게이트 분리 — Product와 Stock은 왜 따로인가

같은 바운디드 컨텍스트 안에서도 "어디까지를 하나의 단위로 묶을 것인가"를 결정해야 한다. 이게 어그리게이트 경계다.

Product와 Stock은 1:1 관계인데, 왜 하나로 합치지 않았을까?

[이전 글](https://velog.io/@praesentia-ykm)의 트레이드오프 분석에서 이미 결정한 내용이지만 DDD 관점에서 다시 한번 증명해보면, 핵심 기준은 **"같이 잠글 필요가 있는가?"**다.

| 변경 시나리오 | Product 변경? | Stock 변경? | 결론 |
|-------------|:----------:|:----------:|------|
| 상품명 수정 | O | X | 독립 |
| 가격 수정 | O | X | 독립 |
| 재고 차감 (주문) | X | O | 독립 |
| 상품 등록 (초기 재고 포함) | O | O | Facade에서 조율 |

4개 시나리오 중 3개가 독립적이다. 상품 정보를 수정할 때 재고를 잠글 필요가 없고, 재고를 차감할 때 상품 정보를 잠글 필요가 없다.

유일하게 둘 다 변경되는 "상품 등록"은 Facade에서 조율한다. 이건 **비즈니스 규칙이 아니라 절차**다. "상품을 등록하면서 초기 재고도 만든다"는 순서의 문제이지, 둘이 반드시 원자적으로 잠겨야 하는 건 아니다.

```java
// ProductFacade — 절차를 조율
@Transactional
public ProductModel register(..., Long brandId, int initialStock) {
    brandService.getBrand(brandId);                          // 1. 브랜드 존재 확인
    ProductModel product = productService.register(...);     // 2. 상품 생성
    stockService.create(product.getId(), initialStock);      // 3. 재고 생성
    return product;
}
```

**어그리게이트 분리 기준을 한 문장으로:**

> **같이 잠글 필요 없으면 별도 어그리게이트. 동시 변경이 필요한 경우는 Facade에서 조율.**

---

## 도메인 서비스 vs 애플리케이션 서비스 — 가장 많이 헷갈린 구분

설계하면서 가장 오래 고민한 건 이거다. **"이 로직을 `domain/XxxService`에 둘까, `application/XxxFacade`에 둘까?"**

### "규칙"인가, "절차"인가

결론부터 말하면, 판별 기준은 하나다.

> **규칙이면 도메인 서비스. 절차면 애플리케이션 서비스.**

이것만으로는 부족하다. "규칙"과 "절차"가 뭔지를 구분할 수 있어야 한다.

**규칙(Rule):** "같은 이름의 브랜드는 등록할 수 없다." 이건 사업부에서 정한 비즈니스 제약이다. 이 규칙을 빼면 시스템의 일관성이 깨진다.

```java
// BrandService (도메인 서비스) — 규칙을 담는다
public BrandModel register(String name, String description) {
    brandRepository.findByName(name).ifPresent(existing -> {
        throw new CoreException(ErrorType.CONFLICT);  // ← 비즈니스 규칙
    });
    return brandRepository.save(new BrandModel(name, description));
}
```

**절차(Procedure):** "상품을 등록할 때는 브랜드 존재를 확인하고, 상품을 만들고, 재고를 만든다." 이건 순서다. 각 단계의 규칙은 각자의 도메인 서비스가 갖고 있고, Facade는 "어떤 순서로 호출할지"만 안다.

```java
// ProductFacade (애플리케이션 서비스) — 절차를 조율한다
public ProductModel register(..., Long brandId, int initialStock) {
    brandService.getBrand(brandId);                          // 1. 위임
    ProductModel product = productService.register(...);     // 2. 위임
    stockService.create(product.getId(), initialStock);      // 3. 위임
    return product;                                          // ← 자체 규칙 없음
}
```

### 구분의 리트머스 테스트

더 실용적인 판별법 네 가지.

| 질문 | 도메인 서비스 | 애플리케이션 서비스 |
|------|-------------|-------------------|
| 자체 비즈니스 규칙이 있는가? | **있다** (유니크 검증, 상태 전이, 음수 방지) | **없다** (위임만 수행) |
| 다른 Service를 조합하는가? | 같은 도메인 내 객체만 다룬다 | **여러 도메인 Service를 조합**한다 |
| `@Transactional` 경계인가? | 아닐 수 있다 | **맞다** (유스케이스 단위) |
| 이걸 제거하면? | **비즈니스 규칙이 깨진다** | 절차가 사라질 뿐, 규칙은 유지된다 |

4번이 가장 강력한 리트머스다. `BrandService`를 제거하면 "같은 이름 브랜드 방지" 규칙이 사라진다. `ProductFacade`를 제거하면? 각 도메인 서비스의 규칙은 그대로 남아있고, "이 순서로 호출하는" 편의만 사라진다.

### 판별 범위 한정

이 "규칙 vs 절차" 구분은 **도메인 계층과 애플리케이션 계층 사이에서만** 유효하다. Controller(HTTP 요청/응답 변환)나 Repository(데이터 저장소 접근)에는 적용하지 않는다. Controller에 "규칙이 있느냐"고 물으면 "없다"인데, 그렇다고 Controller가 애플리케이션 서비스인 건 아니다.

---

## 컨텍스트 매핑 — 나눈 것들이 대화하는 방법

바운디드 컨텍스트를 나눠 놓고 끝이 아니다. **"얘네가 서로 어떻게 대화하는가?"**를 정해야 한다.

현재 프로젝트의 의존 관계를 그려보면:

```
                ┌─────────────┐
                │ 회원/인증 BC │
                │  (Generic)  │
                └──────┬──────┘
                       │ userId
              ┌────────┼────────┐
              ▼        ▼        │
        ┌──────────┐ ┌────────┐ │
        │좋아요 BC │ │주문 BC │ │
        │(Support) │ │(Core)  │ │
        └────┬─────┘ └───┬────┘ │
             │            │      │
    likeCount│    재고차감 │      │
    갱신     │            ▼      │
             │     ┌──────────┐  │
             │     │ 재고 BC  │  │
             │     │(Support) │  │
             │     └────┬─────┘  │
             │          │        │
             ▼     productId     │
        ┌───────────────┴────────┘
        │    카탈로그 BC (Core)
        │   Brand ── Product
        └────────────────────────
```

모놀리스에서는 Facade가 다른 도메인의 Service를 직접 호출한다.

| 호출 | 방식 | 시스템 분리 시 전환 |
|------|------|-------------------|
| `ProductFacade` → `BrandService` | 직접 호출 | 같은 BC, 분리 불필요 |
| `ProductFacade` → `StockService` | 직접 호출 | API 호출 또는 이벤트 |
| `LikeFacade` → `ProductService` | 직접 호출 | **도메인 이벤트** |
| `OrderFacade` → `ProductService` + `StockService` | 직접 호출 | Saga 패턴 |

여기서 한 가지 설계적 주의 지점이 있다.

```java
// LikeFacade — 좋아요 BC가 카탈로그 BC의 엔티티를 직접 수정한다
public void like(Long userId, Long productId) {
    ProductModel product = productService.getProduct(productId);
    // ... 좋아요 로직
    product.incrementLikeCount();  // ← 다른 BC의 엔티티를 직접 변경
}
```

모놀리스에서는 이게 실용적이다. 하지만 이 코드가 **BC 경계를 넘는 직접 수정**이라는 사실은 인식하고 있어야 한다. 시스템이 커져서 물리적으로 분리할 때, 이 부분은 도메인 이벤트로 전환해야 한다.

> 좋아요 발생 → `LikeCreatedEvent` 발행 → 카탈로그 BC가 수신 → `likeCount` 갱신

"지금은 직접 호출하되, 여기가 나중에 잘라야 할 지점"이라는 걸 아는 것과 모르는 것은 다르다. 컨텍스트 매핑의 가치가 여기에 있다.

---

## 현재 프로젝트의 전체 배치

지금까지의 판별 기준을 적용한 결과물이다.

### 도메인 서비스 (규칙)

| 컴포넌트 | 담당 규칙 |
|---------|---------|
| `BrandService` | 브랜드명 유니크 검증, CRUD |
| `ProductService` | 상품 CRUD, likeCount 증감, soft delete |
| `StockService` | 재고 생성, `checkAndDecrease` (음수 방지) |
| `LikeService` | 좋아요 등록/취소, 멱등성, 존재 여부 조회 |
| `OrderService` | 주문 생성, 총액 계산 |

### 애플리케이션 서비스 (절차)

| 컴포넌트 | 조율하는 절차 |
|---------|------------|
| `BrandFacade` | 브랜드 삭제 → 소속 상품 연쇄 soft delete |
| `ProductFacade` | 브랜드 존재 확인 → 상품 생성 → 재고 생성 |
| `LikeFacade` | 삭제된 상품 체크 → 좋아요 처리 → likeCount 동기화 |
| `OrderFacade` | 상품 조회 → 삭제 검증 → 재고 차감 → 주문 생성 (All or Nothing) |

모든 Facade에는 공통점이 있다. **자체 규칙이 없고, 여러 도메인 서비스를 순서대로 호출**한다. 각 단계의 비즈니스 규칙은 해당 도메인 서비스가 갖고 있다.

---

## 회고 — 나만의 판별 기준 세 줄

DDD 책을 읽으면 "컨텍스트 경계를 잘 나누세요", "도메인 서비스에 비즈니스 로직을 두세요"라고 한다. 맞는 말인데, **"잘"이 뭔데?**

이번 프로젝트를 거치며 내가 내린 판별 기준은 세 가지다.

**1. 바운디드 컨텍스트 경계:**
> 같은 단어가 다른 속성/행위를 요구하면 경계다. 하나의 트랜잭션으로 묶여야 하면 같은 BC다.

**2. 어그리게이트 분리:**
> 같이 잠글 필요가 없으면 별도 어그리게이트. 동시 변경은 Facade에서 조율.

**3. 도메인 서비스 vs 애플리케이션 서비스:**
> 제거했을 때 비즈니스 규칙이 깨지면 도메인 서비스. 절차만 사라지면 애플리케이션 서비스.

이 세 줄이 모든 경우를 커버하진 않는다. 하지만 "어디에 뭘 둬야 하지?"라는 고민의 출발점으로는 충분했다. 적어도 감으로 결정하는 것보다, **기준을 들이대고 검증할 수 있다**는 점에서 설계의 질이 달라졌다.


